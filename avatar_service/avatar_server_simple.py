"""
Luna Avatar Service - Simple Working Version
=============================================
This uses direct subprocess calls to SadTalker
"""
import os
import sys
import subprocess
from pathlib import Path
import uuid
import logging
from typing import Optional
from fastapi import FastAPI, HTTPException, BackgroundTasks
from fastapi.responses import FileResponse
from pydantic import BaseModel
import uvicorn
import torch

# Logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Directories
BASE_DIR = Path(__file__).parent
OUTPUT_DIR = BASE_DIR / "generated_videos"
AUDIO_DIR = BASE_DIR / "generated_audio"
TEMP_DIR = BASE_DIR / "temp_sadtalker"
AVATAR_IMAGE = BASE_DIR / "luna_base.png"

# SadTalker path (update this to your actual SadTalker location)
SADTALKER_PATH = Path(r"C:\Users\Walid\Downloads\SadTalker")

# Create directories
OUTPUT_DIR.mkdir(exist_ok=True)
AUDIO_DIR.mkdir(exist_ok=True)
TEMP_DIR.mkdir(exist_ok=True)

# Device
DEVICE = "cuda" if torch.cuda.is_available() else "cpu"
logger.info(f"Using device: {DEVICE}")

# Check if SadTalker is available
sadtalker_available = SADTALKER_PATH.exists()

app = FastAPI(title="Luna Avatar Service - Simple")


class AvatarRequest(BaseModel):
    text: str
    audio_url: Optional[str] = None
    voice_id: Optional[str] = "default"
    quality: Optional[str] = "fast"
    duration: Optional[float] = None


class AvatarResponse(BaseModel):
    video_url: str
    video_id: str
    duration: float
    status: str
    audio_url: Optional[str] = None


async def generate_audio_with_tts(text: str, output_path: Path) -> float:
    """Generate audio from text using TTS Manager"""
    try:
        # Import TTS Manager
        from tts_manager import TTSManager
        
        tts = TTSManager()
        
        # Generate speech
        success = await tts.generate_speech(text, str(output_path), voice="default")
        
        if not success:
            raise Exception("TTS generation failed with all engines")
        
        # Get duration using ffprobe
        try:
            duration_cmd = [
                "ffprobe",
                "-v", "error",
                "-show_entries", "format=duration",
                "-of", "default=noprint_wrappers=1:nokey=1",
                str(output_path)
            ]
            
            result = subprocess.run(duration_cmd, capture_output=True, text=True)
            duration = float(result.stdout.strip())
        except:
            # Estimate duration if ffprobe fails (roughly 150 words per minute)
            words = len(text.split())
            duration = (words / 150) * 60
        
        return duration
    except Exception as e:
        logger.error(f"TTS generation failed: {e}")
        raise


def generate_video_with_sadtalker(audio_path: Path, source_image: Path, output_dir: Path, video_id: str, quality: str = "fast") -> Path:
    """Generate video using SadTalker via subprocess"""
    
    if not sadtalker_available:
        raise Exception("SadTalker not found")
    
    # Create output subdirectory for this video
    video_temp_dir = TEMP_DIR / video_id
    video_temp_dir.mkdir(exist_ok=True)
    
    # Build SadTalker command - use SadTalker's own Python venv
    sadtalker_python = SADTALKER_PATH / "venv" / "Scripts" / "python.exe"
    if not sadtalker_python.exists():
        # Fallback to system python if no venv
        sadtalker_python = sys.executable
    
    cmd = [
        str(sadtalker_python),
        str(SADTALKER_PATH / "inference.py"),
        "--driven_audio", str(audio_path),
        "--source_image", str(source_image),
        "--result_dir", str(video_temp_dir),
        "--still",
        "--preprocess", "full",
        "--expression_scale", "1.0"
    ]
    
    # Quality settings
    if quality == "fast":
        cmd.extend(["--size", "256"])
    elif quality == "high":
        cmd.extend(["--size", "512", "--enhancer", "gfpgan"])
    else:  # standard
        cmd.extend(["--size", "256", "--enhancer", "gfpgan"])
    
    logger.info(f"ðŸŽ¬ Generating {quality} quality video...")
    
    # Run SadTalker
    result = subprocess.run(cmd, capture_output=True, text=True)
    
    if result.returncode != 0:
        logger.error(f"SadTalker error: {result.stderr}")
        raise Exception(f"SadTalker failed: {result.stderr}")
    
    # Find the generated video
    generated_videos = list(video_temp_dir.rglob("*.mp4"))
    if not generated_videos:
        raise Exception("No video generated by SadTalker")
    
    # Copy to output directory
    final_output = output_dir / f"{video_id}.mp4"
    import shutil
    shutil.copy2(generated_videos[0], final_output)
    
    return final_output


@app.get("/health")
async def health_check():
    """Health check endpoint"""
    gpu_info = {}
    if DEVICE == "cuda":
        gpu_info = {
            "name": torch.cuda.get_device_name(0),
            "memory_allocated": f"{torch.cuda.memory_allocated(0) / 1024**3:.2f} GB",
            "memory_reserved": f"{torch.cuda.memory_reserved(0) / 1024**3:.2f} GB",
        }
    
    return {
        "status": "healthy",
        "model_loaded": sadtalker_available,
        "device": DEVICE,
        "gpu_info": gpu_info,
    }


@app.post("/generate", response_model=AvatarResponse)
async def generate_avatar(request: AvatarRequest, background_tasks: BackgroundTasks):
    """Generate avatar video"""
    
    if not AVATAR_IMAGE.exists():
        raise HTTPException(status_code=500, detail="luna_base.png not found")
    
    if not sadtalker_available:
        raise HTTPException(status_code=503, detail="SadTalker not available")
    
    video_id = str(uuid.uuid4())
    audio_path = AUDIO_DIR / f"{video_id}.mp3"
    
    try:
        logger.info(f"ðŸ“¨ New request: {request.text[:50]}...")
        logger.info(f"   Quality: {request.quality}")
        
        # Step 1: Generate audio
        logger.info("ðŸŽ¤ Generating audio...")
        duration = await generate_audio_with_tts(request.text, audio_path)
        logger.info(f"âœ“ Audio generated: {duration:.1f}s")
        
        # Step 2: Generate video with SadTalker
        video_path = generate_video_with_sadtalker(
            audio_path=audio_path,
            source_image=AVATAR_IMAGE,
            output_dir=OUTPUT_DIR,
            video_id=video_id,
            quality=request.quality
        )
        
        logger.info(f"âœ“ Video ready: {video_id}.mp4")
        
        return AvatarResponse(
            video_url=f"http://localhost:8000/videos/{video_id}.mp4",
            audio_url=f"http://localhost:8000/audio/{video_id}.mp3",
            video_id=video_id,
            duration=duration,
            status="generated"
        )
        
    except Exception as e:
        logger.error(f"Error generating avatar: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/videos/{filename}")
async def get_video(filename: str):
    """Serve generated video"""
    video_path = OUTPUT_DIR / filename
    
    if not video_path.exists():
        logger.warning(f"Video not found: {filename}")
        raise HTTPException(status_code=404, detail="Video not found")
    
    return FileResponse(
        video_path,
        media_type="video/mp4",
        headers={"Content-Disposition": f"inline; filename={filename}"}
    )


@app.get("/audio/{filename}")
async def get_audio(filename: str):
    """Serve generated audio"""
    audio_path = AUDIO_DIR / filename
    
    if not audio_path.exists():
        raise HTTPException(status_code=404, detail="Audio not found")
    
    return FileResponse(
        audio_path,
        media_type="audio/mpeg",
        headers={"Content-Disposition": f"inline; filename={filename}"}
    )


if __name__ == "__main__":
    logger.info("=== Luna Avatar Service Starting ===")
    logger.info(f"SadTalker path: {SADTALKER_PATH}")
    logger.info(f"SadTalker available: {sadtalker_available}")
    logger.info(f"Avatar image: {AVATAR_IMAGE.exists()}")
    logger.info(f"GPU: {DEVICE}")
    
    if DEVICE == "cuda":
        logger.info(f"GPU Name: {torch.cuda.get_device_name(0)}")
    
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=8000,
        log_level="info"
    )

